<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive color wheel for Ohuhu markers with color harmony modes.">
  <title>Ohuhu Color Wheel</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      text-align: center;
      background: #f5f5f5;
      min-height: 100vh;
    }

    h1 {
      margin-bottom: 10px;
      color: #333;
    }

    .subtitle {
      color: #666;
      margin-bottom: 20px;
      font-size: 14px;
    }

    /* Filter buttons */
    .filter-section {
      margin-bottom: 20px;
    }

    .filter-label {
      font-weight: bold;
      margin-right: 10px;
      color: #555;
    }

    .btn-group {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin: 5px 0;
    }

    .btn {
      padding: 8px 16px;
      border: 2px solid #ccc;
      background: white;
      border-radius: 20px;
      cursor: pointer;
      font-family: Verdana, sans-serif;
      font-size: 13px;
      transition: all 0.2s;
    }

    .btn:hover {
      border-color: #888;
      background: #f0f0f0;
    }

    .btn.active {
      background: #333;
      color: white;
      border-color: #333;
    }

    /* Main layout */
    .main-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      margin-top: 20px;
    }

    /* Color wheel */
    .wheel-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .wheel-size-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
      font-size: 13px;
      color: #555;
    }

    .wheel-size-control label {
      font-weight: bold;
    }

    .wheel-size-control input[type="range"] {
      width: 120px;
      cursor: pointer;
    }

    #wheelSizeLabel {
      min-width: 50px;
      text-align: left;
    }

    .wheel-container {
      position: relative;
      width: 400px;
      height: 400px;
      transition: width 0.2s, height 0.2s;
    }

    .wheel-background {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: conic-gradient(
        from 0deg,
        hsl(0, 100%, 50%),
        hsl(30, 100%, 50%),
        hsl(60, 100%, 50%),
        hsl(90, 100%, 50%),
        hsl(120, 100%, 50%),
        hsl(150, 100%, 50%),
        hsl(180, 100%, 50%),
        hsl(210, 100%, 50%),
        hsl(240, 100%, 50%),
        hsl(270, 100%, 50%),
        hsl(300, 100%, 50%),
        hsl(330, 100%, 50%),
        hsl(360, 100%, 50%)
      );
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    .wheel-background::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0) 70%);
    }

    .wheel-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .marker-dot {
      cursor: pointer;
      transition: all 0.15s;
    }

    .marker-dot:hover {
      filter: brightness(1.1);
    }

    .marker-dot.selected {
      stroke: white;
      stroke-width: 3;
      filter: drop-shadow(0 0 6px rgba(0,0,0,0.5));
    }

    .harmony-line {
      stroke: rgba(255, 255, 255, 0.8);
      stroke-width: 2;
      stroke-dasharray: 5, 5;
      pointer-events: none;
    }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      z-index: 100;
      white-space: nowrap;
      display: none;
    }

    .tooltip.visible {
      display: block;
    }

    /* Info panel */
    .info-panel {
      width: 300px;
      text-align: left;
    }

    .selected-marker {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .selected-marker h3 {
      margin: 0 0 10px 0;
      color: #333;
    }

    .selected-color-preview {
      width: 100%;
      height: 80px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .marker-details {
      font-size: 13px;
      color: #666;
    }

    .marker-details p {
      margin: 5px 0;
    }

    .marker-details strong {
      color: #333;
    }

    .new-code-display {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      background: #f0f0f0;
      padding: 8px 15px;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 12px;
      font-family: monospace;
      letter-spacing: 1px;
    }

    /* Harmony palette */
    .harmony-section h3 {
      margin: 0 0 15px 0;
      color: #333;
    }

    .harmony-palette {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .color-block {
      width: 130px;
      height: 130px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      transition: transform 0.2s;
    }

    .color-block:hover {
      transform: scale(1.05);
    }

    .color-block .color-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      padding: 8px;
      text-align: center;
      font-size: 12px;
      line-height: 1.2;
    }

    .color-block .label {
      font-weight: bold;
      font-size: 12px;
      margin-bottom: 4px;
    }

    .color-block .hex-code {
      font-family: monospace;
      font-size: 11px;
      margin-top: auto;
    }

    .color-block .code {
      font-size: 10px;
      opacity: 0.8;
    }

    /* Instructions */
    .instructions {
      margin-top: 20px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      font-size: 13px;
      color: #666;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .instructions h4 {
      margin: 0 0 10px 0;
      color: #333;
    }

    /* Responsive */
    @media (max-width: 800px) {
      .wheel-container {
        width: 320px;
        height: 320px;
      }

      .info-panel {
        width: 100%;
        max-width: 400px;
      }

      .color-block {
        width: 100px;
        height: 100px;
      }
    }

    @media (max-width: 400px) {
      .wheel-container {
        width: 280px;
        height: 280px;
      }
    }

    /* Marker search/list */
    .marker-search-section {
      margin-bottom: 20px;
    }

    .search-container {
      position: relative;
      display: inline-block;
      width: 300px;
      max-width: 90vw;
    }

    .marker-search {
      width: 100%;
      padding: 10px 15px;
      font-size: 14px;
      font-family: Verdana, sans-serif;
      border: 2px solid #ccc;
      border-radius: 25px;
      outline: none;
      transition: border-color 0.2s;
    }

    .marker-search:focus {
      border-color: #666;
    }

    .marker-search::placeholder {
      color: #999;
    }

    .marker-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: white;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
      z-index: 200;
      display: none;
      margin-top: 5px;
    }

    .marker-list.visible {
      display: block;
    }

    .marker-list-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      cursor: pointer;
      transition: background 0.15s;
      border-bottom: 1px solid #eee;
    }

    .marker-list-item:last-child {
      border-bottom: none;
    }

    .marker-list-item:hover {
      background: #f5f5f5;
    }

    .marker-list-item.highlighted {
      background: #e8e8e8;
    }

    .marker-swatch {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      margin-right: 12px;
      flex-shrink: 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .marker-list-info {
      text-align: left;
      flex-grow: 1;
    }

    .marker-list-name {
      font-weight: bold;
      font-size: 13px;
      color: #333;
    }

    .marker-list-code {
      font-size: 11px;
      color: #888;
      margin-top: 2px;
    }

    .no-results {
      padding: 15px;
      text-align: center;
      color: #888;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <h1>Ohuhu Color Wheel</h1>
  <p class="subtitle">Click a marker dot to see color harmonies</p>

  <!-- Marker line filter -->
  <div class="filter-section">
    <span class="filter-label">Marker Line:</span>
    <div class="btn-group" id="lineFilter">
      <button class="btn active" data-line="all">All</button>
      <button class="btn" data-line="Honolulu">Honolulu</button>
      <button class="btn" data-line="Oahu">Oahu</button>
      <button class="btn" data-line="Kaala">Kaala</button>
    </div>
  </div>

  <!-- Harmony mode selector -->
  <div class="filter-section">
    <span class="filter-label">Harmony Mode:</span>
    <div class="btn-group" id="harmonyMode">
      <button class="btn active" data-mode="complementary">Complementary</button>
      <button class="btn" data-mode="analogous">Analogous</button>
      <button class="btn" data-mode="triadic">Triadic</button>
      <button class="btn" data-mode="tetradic">Tetradic</button>
      <button class="btn" data-mode="splitComplementary">Split-Comp</button>
      <button class="btn" data-mode="monochromatic">Monochromatic</button>
    </div>
  </div>

  <!-- Marker search -->
  <div class="marker-search-section">
    <span class="filter-label">Find Marker:</span>
    <div class="search-container">
      <input type="text"
             class="marker-search"
             id="markerSearch"
             placeholder="Search by name or code..."
             autocomplete="off">
      <div class="marker-list" id="markerList"></div>
    </div>
  </div>

  <!-- Main content -->
  <div class="main-container">
    <!-- Color wheel -->
    <div class="wheel-wrapper">
      <div class="wheel-size-control">
        <label for="wheelSize">Size:</label>
        <input type="range" id="wheelSize" min="250" max="600" value="400" step="10">
        <span id="wheelSizeLabel">400px</span>
      </div>
      <div class="wheel-container" id="wheelContainer">
        <div class="wheel-background"></div>
        <svg class="wheel-svg" id="wheelSvg" viewBox="0 0 400 400">
          <g id="harmonyLines"></g>
          <g id="markerDots"></g>
        </svg>
        <div class="tooltip" id="tooltip"></div>
      </div>
    </div>

    <!-- Info panel -->
    <div class="info-panel">
      <div class="selected-marker" id="selectedMarker">
        <h3>Selected Marker</h3>
        <div class="selected-color-preview" id="selectedPreview" style="background: #ccc;">
          <span>Click a dot to select</span>
        </div>
        <div class="marker-details" id="markerDetails">
          <p>Select a marker from the wheel to see its details and color harmonies.</p>
        </div>
      </div>

      <div class="harmony-section">
        <h3>Harmony Palette</h3>
        <div class="harmony-palette" id="harmonyPalette">
          <!-- Harmony colors will be rendered here -->
        </div>
      </div>
    </div>
  </div>

  <div class="instructions">
    <h4>How to Use</h4>
    <p>• Click any marker dot on the wheel, or search by name/code to select a base color</p>
    <p>• Choose a harmony mode to find complementary markers</p>
    <p>• Filter by marker line to show only markers you own</p>
    <p>• Click harmony palette colors to select them as the new base</p>
  </div>

  <script>
    // State
    let colorData = {};
    let markersWithHSV = [];
    let selectedMarker = null;
    let currentLine = 'all';
    let currentHarmonyMode = 'complementary';

    // Harmony angle calculations
    const harmonies = {
      complementary: [0, 180],
      analogous: [-30, 0, 30],
      triadic: [0, 120, 240],
      tetradic: [0, 90, 180, 270],
      splitComplementary: [0, 150, 210],
      monochromatic: [0] // Will vary by saturation/value instead
    };

    // Convert hex to HSV
    function hexToHSV(hex) {
      hex = hex.replace(/^#/, '');
      const r = parseInt(hex.slice(0, 2), 16) / 255;
      const g = parseInt(hex.slice(2, 4), 16) / 255;
      const b = parseInt(hex.slice(4, 6), 16) / 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;

      let h = 0;
      let s = max === 0 ? 0 : diff / max;
      let v = max;

      if (diff !== 0) {
        switch (max) {
          case r:
            h = 60 * (((g - b) / diff) % 6);
            break;
          case g:
            h = 60 * ((b - r) / diff + 2);
            break;
          case b:
            h = 60 * ((r - g) / diff + 4);
            break;
        }
      }

      h = h < 0 ? h + 360 : h;

      return { h, s: s * 100, v: v * 100 };
    }

    // Calculate brightness for text color
    function calculateBrightness(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return (r * 299 + g * 587 + b * 114) / 1000;
    }

    // Convert HSV position to wheel coordinates
    function hsvToWheelPosition(h, s, radius) {
      // Hue determines angle (0 at right, going counter-clockwise)
      const angle = (h - 90) * (Math.PI / 180); // Offset so red is at top
      // Saturation determines distance from center
      const distance = (s / 100) * radius;

      const x = 200 + Math.cos(angle) * distance;
      const y = 200 + Math.sin(angle) * distance;

      return { x, y };
    }

    // Calculate circular hue distance
    function hueDistance(h1, h2) {
      const diff = Math.abs(h1 - h2);
      return Math.min(diff, 360 - diff);
    }

    // Find nearest marker to target hue
    function findNearestMarker(targetHue, markers, exclude = []) {
      let nearest = null;
      let minDistance = Infinity;

      for (const marker of markers) {
        if (exclude.includes(marker.name)) continue;

        const dist = hueDistance(marker.hsv.h, targetHue);
        // Weight saturation difference slightly
        const satDiff = Math.abs(marker.hsv.s - 50) * 0.1;
        const totalDist = dist + satDiff;

        if (totalDist < minDistance) {
          minDistance = totalDist;
          nearest = marker;
        }
      }

      return nearest;
    }

    // Find markers for monochromatic harmony (same hue, different S/V)
    function findMonochromaticMarkers(baseMarker, markers, count = 3) {
      const baseHue = baseMarker.hsv.h;
      const results = [baseMarker];

      // Sort markers by hue distance, then saturation
      const sameHueMarkers = markers
        .filter(m => m.name !== baseMarker.name && hueDistance(m.hsv.h, baseHue) < 30)
        .sort((a, b) => {
          const aDiff = Math.abs(a.hsv.s - baseMarker.hsv.s) + Math.abs(a.hsv.v - baseMarker.hsv.v);
          const bDiff = Math.abs(b.hsv.s - baseMarker.hsv.s) + Math.abs(b.hsv.v - baseMarker.hsv.v);
          return bDiff - aDiff; // Most different first
        });

      // Pick markers with varying saturation/value
      for (const marker of sameHueMarkers) {
        if (results.length >= count) break;

        // Avoid duplicates and very similar markers
        const isDifferentEnough = results.every(r =>
          Math.abs(r.hsv.s - marker.hsv.s) > 10 || Math.abs(r.hsv.v - marker.hsv.v) > 10
        );

        if (isDifferentEnough) {
          results.push(marker);
        }
      }

      return results;
    }

    // Generate harmony palette
    function generateHarmonyPalette(anchor, mode) {
      const visibleMarkers = getVisibleMarkers();

      if (mode === 'monochromatic') {
        return findMonochromaticMarkers(anchor, visibleMarkers, 5);
      }

      const angles = harmonies[mode];
      const palette = [];
      const excluded = [];

      for (const angleOffset of angles) {
        const targetHue = (anchor.hsv.h + angleOffset + 360) % 360;
        const marker = findNearestMarker(targetHue, visibleMarkers, excluded);

        if (marker) {
          palette.push(marker);
          excluded.push(marker.name);
        }
      }

      return palette;
    }

    // Get markers visible with current filter
    function getVisibleMarkers() {
      if (currentLine === 'all') {
        return markersWithHSV;
      }
      return markersWithHSV.filter(m => m.lines.includes(currentLine));
    }

    // Load color data
    async function loadColorData() {
      try {
        const response = await fetch('ColorData.json');
        colorData = await response.json();

        // Process markers and compute HSV
        markersWithHSV = [];

        for (const [name, data] of Object.entries(colorData)) {
          if (!data.Hex || name === 'Colorless Blender') continue;

          const hsv = hexToHSV(data.Hex);
          const lines = [];

          if (data.Honolulu) lines.push('Honolulu');
          if (data.Oahu) lines.push('Oahu');
          if (data.Kaala) lines.push('Kaala');

          // Skip markers without any line assignment (new codes only)
          if (lines.length === 0) lines.push('all');

          markersWithHSV.push({
            name,
            hex: data.Hex,
            code: data.New,
            hsv,
            lines,
            data
          });
        }

        createMarkerDots();
      } catch (error) {
        console.error('Error loading color data:', error);
      }
    }

    // Create marker dots on wheel
    function createMarkerDots() {
      const dotsGroup = document.getElementById('markerDots');
      const radius = 170; // Max distance from center

      dotsGroup.innerHTML = '';

      const visibleMarkers = getVisibleMarkers();

      for (const marker of visibleMarkers) {
        const pos = hsvToWheelPosition(marker.hsv.h, marker.hsv.s, radius);

        // Adjust dot opacity based on value (darker = more transparent)
        const opacity = 0.5 + (marker.hsv.v / 100) * 0.5;

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', pos.x);
        circle.setAttribute('cy', pos.y);
        circle.setAttribute('r', 8);
        circle.setAttribute('fill', marker.hex);
        circle.setAttribute('opacity', opacity);
        circle.setAttribute('class', 'marker-dot');
        circle.setAttribute('data-name', marker.name);

        // Event listeners
        circle.addEventListener('click', () => selectMarker(marker));
        circle.addEventListener('mouseenter', (e) => showTooltip(e, marker));
        circle.addEventListener('mouseleave', hideTooltip);

        dotsGroup.appendChild(circle);
      }

      // Re-select current marker if still visible
      if (selectedMarker) {
        const stillVisible = visibleMarkers.find(m => m.name === selectedMarker.name);
        if (stillVisible) {
          selectMarker(stillVisible);
        } else {
          clearSelection();
        }
      }
    }

    // Show tooltip
    function showTooltip(event, marker) {
      const tooltip = document.getElementById('tooltip');
      const container = document.getElementById('wheelContainer');
      const rect = container.getBoundingClientRect();

      tooltip.textContent = `${marker.name} (${marker.code})`;
      tooltip.classList.add('visible');

      const x = event.clientX - rect.left + 15;
      const y = event.clientY - rect.top - 10;

      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;
    }

    // Hide tooltip
    function hideTooltip() {
      document.getElementById('tooltip').classList.remove('visible');
    }

    // Select a marker
    function selectMarker(marker) {
      selectedMarker = marker;

      // Update dot visuals
      document.querySelectorAll('.marker-dot').forEach(dot => {
        dot.classList.toggle('selected', dot.getAttribute('data-name') === marker.name);
      });

      // Update selected marker display
      const preview = document.getElementById('selectedPreview');
      const brightness = calculateBrightness(marker.hex);
      const textColor = brightness > 128 ? '#000' : '#fff';

      preview.style.background = marker.hex;
      preview.style.color = textColor;
      preview.innerHTML = `<span>${marker.name}</span>`;

      // Update marker details
      const details = document.getElementById('markerDetails');
      const honolulu = marker.data.Honolulu || '—';
      const oahu = marker.data.Oahu || '—';
      const kaala = marker.data.Kaala || '—';
      details.innerHTML = `
        <div class="new-code-display">${marker.code}</div>
        <p><strong>Honolulu:</strong> ${honolulu}</p>
        <p><strong>Oahu:</strong> ${oahu}</p>
        <p><strong>Kaala:</strong> ${kaala}</p>
        <p><strong>Hex:</strong> ${marker.hex}</p>
      `;

      // Generate and render harmony palette
      renderHarmonyPalette();
      drawHarmonyLines();
    }

    // Clear selection
    function clearSelection() {
      selectedMarker = null;

      document.querySelectorAll('.marker-dot').forEach(dot => {
        dot.classList.remove('selected');
      });

      const preview = document.getElementById('selectedPreview');
      preview.style.background = '#ccc';
      preview.style.color = '#666';
      preview.innerHTML = '<span>Click a dot to select</span>';

      document.getElementById('markerDetails').innerHTML =
        '<p>Select a marker from the wheel to see its details and color harmonies.</p>';

      document.getElementById('harmonyPalette').innerHTML = '';
      document.getElementById('harmonyLines').innerHTML = '';
    }

    // Render harmony palette
    function renderHarmonyPalette() {
      if (!selectedMarker) return;

      const palette = generateHarmonyPalette(selectedMarker, currentHarmonyMode);
      const container = document.getElementById('harmonyPalette');

      container.innerHTML = palette.map(marker => {
        const brightness = calculateBrightness(marker.hex);
        const textColor = brightness > 128 ? '#000' : '#fff';

        return `
          <div class="color-block"
               style="background: ${marker.hex}; color: ${textColor};"
               data-name="${marker.name}"
               onclick="selectMarkerByName('${marker.name}')">
            <div class="color-info">
              <div class="label">${marker.name}</div>
              <div class="code">${marker.code}</div>
              <div class="hex-code">${marker.hex}</div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Draw harmony lines on wheel
    function drawHarmonyLines() {
      if (!selectedMarker) return;

      const linesGroup = document.getElementById('harmonyLines');
      const palette = generateHarmonyPalette(selectedMarker, currentHarmonyMode);
      const radius = 170;

      linesGroup.innerHTML = '';

      if (palette.length < 2) return;

      // Draw lines connecting harmony colors
      const centerX = 200;
      const centerY = 200;

      for (let i = 0; i < palette.length; i++) {
        const pos1 = hsvToWheelPosition(palette[i].hsv.h, palette[i].hsv.s, radius);
        const pos2 = hsvToWheelPosition(palette[(i + 1) % palette.length].hsv.h, palette[(i + 1) % palette.length].hsv.s, radius);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', pos1.x);
        line.setAttribute('y1', pos1.y);
        line.setAttribute('x2', pos2.x);
        line.setAttribute('y2', pos2.y);
        line.setAttribute('class', 'harmony-line');
        linesGroup.appendChild(line);
      }
    }

    // Select marker by name (for clicking harmony palette)
    function selectMarkerByName(name) {
      const marker = markersWithHSV.find(m => m.name === name);
      if (marker) {
        selectMarker(marker);
      }
    }

    // Search functionality
    let searchHighlightIndex = -1;
    let filteredMarkers = [];

    function filterMarkers(query) {
      if (!query.trim()) {
        return [];
      }

      const q = query.toLowerCase();
      const visibleMarkers = getVisibleMarkers();

      return visibleMarkers.filter(marker =>
        marker.name.toLowerCase().includes(q) ||
        marker.code.toLowerCase().includes(q)
      ).slice(0, 20); // Limit results
    }

    function renderMarkerList(markers) {
      const list = document.getElementById('markerList');

      if (markers.length === 0) {
        const query = document.getElementById('markerSearch').value.trim();
        if (query) {
          list.innerHTML = '<div class="no-results">No markers found</div>';
          list.classList.add('visible');
        } else {
          list.classList.remove('visible');
        }
        return;
      }

      list.innerHTML = markers.map((marker, index) => `
        <div class="marker-list-item ${index === searchHighlightIndex ? 'highlighted' : ''}"
             data-index="${index}"
             data-name="${marker.name}">
          <div class="marker-swatch" style="background: ${marker.hex};"></div>
          <div class="marker-list-info">
            <div class="marker-list-name">${marker.name}</div>
            <div class="marker-list-code">${marker.code}</div>
          </div>
        </div>
      `).join('');

      list.classList.add('visible');
    }

    function hideMarkerList() {
      document.getElementById('markerList').classList.remove('visible');
      searchHighlightIndex = -1;
    }

    function handleSearchInput(e) {
      const query = e.target.value;
      searchHighlightIndex = -1;
      filteredMarkers = filterMarkers(query);
      renderMarkerList(filteredMarkers);
    }

    function handleSearchKeydown(e) {
      const list = document.getElementById('markerList');
      if (!list.classList.contains('visible') || filteredMarkers.length === 0) {
        return;
      }

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        searchHighlightIndex = Math.min(searchHighlightIndex + 1, filteredMarkers.length - 1);
        renderMarkerList(filteredMarkers);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        searchHighlightIndex = Math.max(searchHighlightIndex - 1, 0);
        renderMarkerList(filteredMarkers);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (searchHighlightIndex >= 0 && searchHighlightIndex < filteredMarkers.length) {
          selectMarker(filteredMarkers[searchHighlightIndex]);
          document.getElementById('markerSearch').value = '';
          hideMarkerList();
        }
      } else if (e.key === 'Escape') {
        hideMarkerList();
        document.getElementById('markerSearch').blur();
      }
    }

    function handleMarkerListClick(e) {
      const item = e.target.closest('.marker-list-item');
      if (item) {
        const name = item.dataset.name;
        const marker = markersWithHSV.find(m => m.name === name);
        if (marker) {
          selectMarker(marker);
          document.getElementById('markerSearch').value = '';
          hideMarkerList();
        }
      }
    }

    // Set up event listeners
    function setupEventListeners() {
      // Line filter buttons
      document.getElementById('lineFilter').addEventListener('click', (e) => {
        if (e.target.classList.contains('btn')) {
          document.querySelectorAll('#lineFilter .btn').forEach(btn => btn.classList.remove('active'));
          e.target.classList.add('active');
          currentLine = e.target.dataset.line;
          createMarkerDots();
        }
      });

      // Harmony mode buttons
      document.getElementById('harmonyMode').addEventListener('click', (e) => {
        if (e.target.classList.contains('btn')) {
          document.querySelectorAll('#harmonyMode .btn').forEach(btn => btn.classList.remove('active'));
          e.target.classList.add('active');
          currentHarmonyMode = e.target.dataset.mode;
          if (selectedMarker) {
            renderHarmonyPalette();
            drawHarmonyLines();
          }
        }
      });

      // Wheel size slider
      const wheelSizeSlider = document.getElementById('wheelSize');
      const wheelSizeLabel = document.getElementById('wheelSizeLabel');
      const wheelContainer = document.getElementById('wheelContainer');

      wheelSizeSlider.addEventListener('input', (e) => {
        const size = e.target.value;
        wheelContainer.style.width = size + 'px';
        wheelContainer.style.height = size + 'px';
        wheelSizeLabel.textContent = size + 'px';
      });

      // Marker search
      const searchInput = document.getElementById('markerSearch');
      const markerList = document.getElementById('markerList');

      searchInput.addEventListener('input', handleSearchInput);
      searchInput.addEventListener('keydown', handleSearchKeydown);
      searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim()) {
          filteredMarkers = filterMarkers(searchInput.value);
          renderMarkerList(filteredMarkers);
        }
      });

      markerList.addEventListener('click', handleMarkerListClick);

      // Close list when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-container')) {
          hideMarkerList();
        }
      });
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      setupEventListeners();
      loadColorData();
    });
  </script>
</body>
</html>
